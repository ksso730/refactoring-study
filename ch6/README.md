칠판이 웃으면...?

킥보드 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

# 기본적인 리펙터링 

## 6.1 함수 추출하기
- 크게 의문사항은 없었다.
- 대신에 생각보다 많은 함수들이 추출될 경우에는 또 그 성격에 따라서 클래스로 나눌 필요도 있을것 같다.

## 6.2 함수 인라인하기
- 함수 본문이 이름만큼 명확한 경우, 간접호출을 너무 과하게 쓰는 코드도 흔한 이라인 대상이다.
- 함수 인라인은 최대한 피했었는데, 자주 고민해봐야겠다.

## 6.3 변수 추출하기
- 복잡한 로직을 구성하는 단계마다 `이름`을 붙일 수 있어서 코드의 목적을 훨씩 명확하게 드러낼 수 있다.
- 덩치가 큰 `클래스`에서 공통 동작으로 별도 이름으로 뽑아서 추상화 해두면 그 `객체`를 다룰 때 쉽게 활용할 수 있다.

## 6.4 변수 인라인하기
- 변수 추출하기의 반대.

## 6.5 함수 선언 바꾸기
- 함수로 추출하기, 매개변수 추가하기
    - 추출한 함수를 기존 코드에 하나씩 넣어주고 최종적으로 쓰이지 않게되면 기존코드는 삭제하는 방식.
- 매개변수를 속성으로 : 기존 매개변수(객체)에 대한 의존성이 제거되어 더 넓은 문맥에서 활용가능.

## 6.6 변수 캡슐화 하기
- 데이터는 함수보다 다루기가 어렵다.
    - 데이터는 참조하는 모든 부분을 한번에 바꿔야 코드가 제대로 작동한다.
- 접근범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 `캡슐화`를 한다.
- 복제본 만들기와 클래스로 감싸는 방식은 레코드 구조에서 깊이가 1인 속성들까지만 효과가 있다.

## 6.7 변수이름 바꾸기

- 변수 캡슐화 하기
```js
let tpHd = "untitled";
result += `<h1>${titlie()}</h1>`
setTitle(obj['articleTitle']);
function title() {return tpHd;}
function setTitle(arg) {tpHd = arg}
```
- 이름 바꾸기
```js
let _title = "untitled";
result += `<h1>${titlie()}</h1>`
setTitle(obj['articleTitle']);
function title() {return _title;}
function setTitle(arg) {_title = arg}
```

## 6.8 매개변수 객체 만들기
- 데이터 뭉치를 `데이터 구조로` 묶으면 데이터 사이의 관계가 명확해진다.
- 또한 그 구조에 담길 데이터에 `공통으로 적용되는 동작`을 추출해서 `함수`로 만든다.

## 6.9 여러 함수를 클래스로 묶기
- 클래스로 묶을 때의 두드러진 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 것이다.

## 6.10 여러 함수를 변환 함수로 묶기
- 반복되는 도출 작업들을 한데로 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고, 로직 중복도 막을 수 있다.
- 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다.

## 6.11 단계 쪼개기
- 서로 다른 두 대상을 다루는 코드를 발견하면 별개 모듈로 쪼갠다.
- 각 단계는 자신만의 문제에 집중하기 때문에 나머지 단계에 관해서는 자세히 몰라도 이해할 수 있다.

> 맥락적으로 모든 방법은 객체지향을 향한다. 변수 - 함수 - 클래스 순으로 쪼개고, 동일한 이유로서 변경되는 것끼리 모은다. 로 귀결되는 것 같다.